#
# Copyright 2006, Red Hat, Inc
# Scott Seago <sseago@redhat.com>
#
# derived from pywbem, written by Tim Potter <tpot@hp.com>, Martin Pool <mbp@hp.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#   
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

#"""
#
#Functions to create XML documens and elements conforming to the DMTF
#standard DSP0201, Representation of CIM in XML, v2.2.
#
#  http://www.dmtf.org/standards/wbem/DSP201.html
#  http://www.dmtf.org/standards/published_documents/DSP201.pdf
#
#Elements generated by this module should conform to version 2.2 of the
#DTD:
#
#  http://www.dmtf.org/standards/wbem/CIM_DTD_V22.dtd
#
#There should be one class for each element described in the DTD.  The
#constructors take builtin Python types, or other cim_xml classes where
#child elements are required.
#
#Every class is a subclass of the Element class and so shares the same
#attributes and methods, and can be used with the built-in Python XML
#handling routines.  In particular you can call the toxml() and
#toprettyxml() methods to generate XML.
#
#Note that converting using toprettyxml() inserts whitespace which may
#corrupt the data in the XML (!!) so you should only do this when
#displaying to humans who can ignore it, and never for computers.  XML
#always passes through all non-markup whitespace.
#
#"""

require "rexml/document"

module WBEM

    class CIMElement < REXML::Element
            #"""A base class that has a few bonus helper methods."""

        def initialize(arg)
            super(arg)
        end

        def setName(name)
            #"""Set the NAME attribute of the element."""
            self.add_attribute("NAME", name)
        end

        def add_optional_attribute(name, value)
            #"""Set an attribute if the value is not nil."""        
            self.add_attribute(name, value) unless value.nil?
        end

        def add_optional_element(child)
            #"""Append a child element which can be nil."""
            self.add_element(child) unless child.nil?
        end

        def add_elements(children)
            #"""Append a list or tuple of children."""
            unless children.is_a?(Array) or children.is_a?(Hash)
                children = [children]
            end
            children.each { |child| self.add_element(child) }
        end
        def toxml()
            outstr = ""
            self.write(outstr)
            outstr
        end
    end

    # Root element

    class CIM < CIMElement
        #"""
        #The CIM element is the root element of every XML Document that is
        #valid with respect to this schema. 
        
        #Each document takes one of two forms; it either contains a single
        #MESSAGE element defining a CIM message (to be used in the HTTP
        #mapping), or it contains a DECLARATION element used to declare a
        #set of CIM objects.
        
        #<!ELEMENT CIM (MESSAGE | DECLARATION)>
        #<!ATTLIST CIM
        #    CIMVERSION CDATA #REQUIRED
        #    DTDVERSION CDATA #REQUIRED>
        #"""

        def initialize(data, cim_version, dtd_version)
            super("CIM")
            self.add_attribute("CIMVERSION", cim_version)
            self.add_attribute("DTDVERSION", dtd_version)
            self.add_element(data)
        end
    end

        # Object declaration elements
        
    class DECLARATION < CIMElement
#     """
#     The DECLARATION element defines a set of one or more declarations
#     of CIM objects.  These are partitioned into logical declaration
#     subsets. 
 
#     <!ELEMENT DECLARATION  (DECLGROUP|DECLGROUP.WITHNAME|DECLGROUP.WITHPATH)+>
#     """

        def initialize(data)
            super("DECLARATION")
            self.add_elements(data)
        end
    end

    class DECLGROUP < CIMElement
#     """
#    The DECLGROUP element defines a logical set of CIM Class, Instance
#    and Qualifier declarations.  It MAY optionally include a
#    NAMESPACEPATH or LOCALNAMESPACEPATH element which, if present,
#    defines the common namespace in which all objects within the group
#    are declared.

#     <!ELEMENT DECLGROUP  ((LOCALNAMESPACEPATH|NAMESPACEPATH)?,
#                           QUALIFIER.DECLARATION*,VALUE.OBJECT*)>
#     """

        def initialize(data)
            super("DECLGROUP")
            self.add_elements(data)
        end
    end

    class DECLGROUP_WITHNAME < CIMElement
#     """
#     The DECLGROUP.WITHNAME element defines a logical set of CIM Class,
#     Instance and Qualifier declarations.  It MAY optionally include a
#     NAMESPACEPATH or LOCALNAMESPACEPATH element which, if present,
#     defines the common namespace in which all objects within the group
#     are declared.

#     <!ELEMENT DECLGROUP.WITHNAME  ((LOCALNAMESPACEPATH|NAMESPACEPATH)?,
#                                    QUALIFIER.DECLARATION*,VALUE.NAMEDOBJECT*)>
#     """

        def initialize(data)
            super("DECLGROUP.WITHNAME")
            self.add_elements(data)
        end
    end

    class DECLGROUP_WITHPATH < CIMElement
#     """
#     The DECLGROUP.WITHPATH element defines a logical set of CIM Class
#     and Instance declarations.  Each object is declared with its own
#     independent naming and location information.

#     <!ELEMENT DECLGROUP.WITHPATH  (VALUE.OBJECTWITHPATH |
#                                    VALUE.OBJECTWITHLOCALPATH)*>
#     """

        def initialize(data)
            super("DECLGROUP.WITHPATH")
            self.add_elements(data)
        end
    end

    class QUALIFIER_DECLARATION < CIMElement
#     """
#     The QUALIFIER.DECLARATION element defines a single CIM Qualifier
#     declaration.

#     <!ELEMENT QUALIFIER.DECLARATION (SCOPE?, (VALUE | VALUE.ARRAY)?)>
#     <!ATTLIST QUALIFIER.DECLARATION
#          %CIMName;               
#          %CIMType;               #REQUIRED
#          ISARRAY    (true|false) #IMPLIED
#          %ArraySize;
#          %QualifierFlavor;>
#     """

        def initialize(name, type, data, is_array = nil,
                       array_size = nil, qualifier_flavor = nil)
            super("QUALIFIER.DECLARATION")
            self.setName(name)
            self.add_attribute("TYPE", type)
            self.add_optional_attribute(is_array)
            self.add_optional_attribute(array_size)
            self.add_optional_attribute(qualifier_flavor)
            self.add_elements(data)
        end
    end

    class SCOPE < CIMElement
#     """
#     The SCOPE element defines the scope of a QUALIFIER.DECLARATION in
#     the case that there are restrictions on the scope of the Qualifier
#     declaration.

#     <!ELEMENT SCOPE EMPTY>
#     <!ATTLIST SCOPE 
#          CLASS        (true|false)      'false'
#          ASSOCIATION  (true|false)      'false'
#          REFERENCE    (true|false)      'false'
#          PROPERTY     (true|false)      'false'
#          METHOD       (true|false)      'false'
#          PARAMETER    (true|false)      'false'
#          INDICATION   (true|false)      'false'>
#     """
    
        def initialize(class_ = false, association = false,
                 reference = false, property = false, method = false,
                 parameter = false, indication = false)
            super("SCOPE")
            self.add_attribute("CLASS", class_.to_s)
            self.add_attribute("ASSOCIATION", association.to_s)
            self.add_attribute("REFERENCE", reference.to_s)
            self.add_attribute("PROPERTY", property.to_s)
            self.add_attribute("METHOD", method.to_s)
            self.add_attribute("PARAMETER", parameter.to_s)
            self.add_attribute("INDICATION", indication.to_s)
        end
    end

# Object value elements

    class VALUE < CIMElement
#     """
#     The VALUE element is used to define a single (non-array and
#     non-reference) CIM Property value, CIM Qualifier value, or a CIM
#     Method Parameter value.

#     <!ELEMENT VALUE (#PCDATA)>
#     """

        def initialize(pcdata)
            super("VALUE")
            self.add_text(pcdata) unless pcdata.nil?
        end
    end

    class VALUE_ARRAY < CIMElement
#     """
#     The VALUE.ARRAY element is used to represent the value of a CIM
#     Property or Qualifier that has an array type.

#     <!ELEMENT VALUE.ARRAY (VALUE*)>
#     """

        def initialize(values)
            super("VALUE.ARRAY")
            self.add_elements(values)
        end
    end

    class VALUE_REFERENCE < CIMElement
#     """
#     The VALUE.REFERENCE element is used to define a single CIM
#     reference Property value.

#     <!ELEMENT VALUE.REFERENCE (CLASSPATH | LOCALCLASSPATH | CLASSNAME |
#                                INSTANCEPATH | LOCALINSTANCEPATH |
#                                INSTANCENAME)>
#     """

        def initialize(data)
            super("VALUE.REFERENCE")
            self.add_element(data)
        end
    end

    class VALUE_REFARRAY < CIMElement
#     """
#     The VALUE.REFARRAY element is used to represent the value of an
#     array of CIM references.

#     <!ELEMENT VALUE.REFARRAY (VALUE.REFERENCE*)>
#     """
    
        def initialize(data)
            super("VALUE.REFARRAY")
            self.add_elements(data)
        end
    end

    class VALUE_OBJECT < CIMElement
#     """
#     The VALUE.OBJECT element is used to define a value which is
#     comprised of a single CIM Class or Instance definition.
    
#     <!ELEMENT VALUE.OBJECT (CLASS | INSTANCE)>
#     """

        def initialize(data)
            super("VALUE.OBJECT")
            self.add_element(data)
        end
    end

    class VALUE_NAMEDINSTANCE < CIMElement
#     """
#     The VALUE.NAMEDINSTANCE element is used to define a value which
#     is comprised of a single named CIM Instance definition.
    
#     <!ELEMENT VALUE.NAMEDINSTANCE (INSTANCENAME, INSTANCE)>
#     """

        def initialize(instancename, instance)
            super("VALUE.NAMEDINSTANCE")
            self.add_element(instancename)
            self.add_element(instance)
        end
    end

    class VALUE_NAMEDOBJECT < CIMElement
#     """
#     The VALUE.NAMEDOBJECT element is used to define a value which
#     is comprised of a single named CIM Class or Instance definition. 

#     <!ELEMENT VALUE.NAMEDOBJECT (CLASS | (INSTANCENAME, INSTANCE))>
#     """
    
        def initialize(data)
            super("VALUE.NAMEDOBJECT")
            self.add_elements(data)
        end
    end
    
    class VALUE_OBJECTWITHLOCALPATH < CIMElement
#    """
#    The VALUE.OBJECTWITHLOCALPATH element is used to define a value
#    which is comprised of a single CIM Object (Class or Instance)
#    definition with additional information that defines the local path
#    to that Object.
#
#    <!ELEMENT VALUE.OBJECTWITHLOCALPATH ((LOCALCLASSPATH, CLASS) |
#                                         (LOCALINSTANCEPATH, INSTANCE))>
#    """

        def initialize(data1, data2)
            super("VALUE.OBJECTWITHLOCALPATH")
            self.add_element(data1)
            self.add_element(data2)
        end
    end

    class VALUE_OBJECTWITHPATH < CIMElement
#     """
#     The VALUE.OBJECTWITHPATH element is used to define a value
#     which is comprised of a single CIM Object (Class or Instance)
#     definition with additional information that defines the absolute
#     path to that Object.

#     <!ELEMENT VALUE.OBJECTWITHPATH ((CLASSPATH, CLASS) |
#                                     (INSTANCEPATH, INSTANCE))>
#     """
    
        def initialize(data1, data2)
            super("VALUE.OBJECTWITHPATH")
            self.add_element(data1)
            self.add_element(data2)
        end
    end

    class VALUE_NULL < CIMElement
#    """
#    The VALUE.NULL element is used to represent a TABLECELL that has
#    no assigned value.
    
#    <!ELEMENT VALUE.NULL EMPTY>
#    """

        def initialize
            super("VALUE.NULL")
        end
    end

# Object naming and location elements

    class NAMESPACEPATH < CIMElement
#     """
#     The NAMESPACEPATH element is used to define a Namespace Path. It
#     consists of a HOST element and a LOCALNAMESPACE element.

#     <!ELEMENT NAMESPACEPATH (HOST, LOCALNAMESPACEPATH)> 
#     """

        def initialize(host, localnamespacepath)
            super("NAMESPACEPATH")
            self.add_element(host)
            self.add_element(localnamespacepath)
        end
    end

    class LOCALNAMESPACEPATH < CIMElement
#     """
#     The LOCALNAMESPACEPATH element is used to define a local Namespace
#     path (one without a Host component). It consists of one or more
#     NAMESPACE elements (one for each namespace in the path). 
 
#     <!ELEMENT LOCALNAMESPACEPATH (NAMESPACE+)> 
#     """
    
        def initialize(namespaces)
            super("LOCALNAMESPACEPATH")
            self.add_elements(namespaces)
        end
    end

    class HOST < CIMElement
#     """
#     The HOST element is used to define a single Host. The element
#     content MUST specify a legal value for a hostname in accordance
#     with the CIM specification.
 
#     <!ELEMENT HOST (#PCDATA)> 
#     """
    
        def initialize(pcdata)
            super("HOST")
                unless pcdata.kind_of?(String) # unicode?
                    raise TypeError, "value argument must be a string"
                end
            self.add_text(pcdata)
        end
    end

    class NAMESPACE < CIMElement
#     """
#     The NAMESPACE element is used to define a single Namespace
#     component of a Namespace path.
 
#     <!ELEMENT NAMESPACE EMPTY> 
#     <!ATTLIST NAMESPACE
#         %CIMName;>
#     """
    
        def initialize(name)
            super("NAMESPACE")
            self.setName(name)
        end
    end

    class CLASSPATH < CIMElement
#     """
#     The CLASSPATH element defines the absolute path to a CIM Class. It
#     is formed from a namespace path and Class name. 
 
#     <!ELEMENT CLASSPATH (NAMESPACEPATH, CLASSNAME)>
#     """
    
        def initialize(namespacepath, classname)
            super("CLASSPATH")
            self.add_element(namespacepath)
            self.add_element(classname)
        end
    end

    class LOCALCLASSPATH < CIMElement
#     """
#     The LOCALCLASSPATH element defines the a local path to a CIM
#     Class. It is formed from a local namespace path and Class name. 
 
#     <!ELEMENT LOCALCLASSPATH (LOCALNAMESPACEPATH, CLASSNAME)>
#     """
    
        def initialize(localnamespacepath, classname)
            super("LOCALCLASSPATH")
            self.add_element(localnamespacepath)
            self.add_element(classname)
        end
    end

    class CLASSNAME < CIMElement
#     """
#     The CLASSNAME element defines the qualifying name of a CIM Class.
 
#     <!ELEMENT CLASSNAME EMPTY>
#     <!ATTLIST CLASSNAME
#         %CIMName;>
#     """
    
        def initialize(classname)
            super("CLASSNAME")
            self.setName(classname)
        end
    end

    class INSTANCEPATH < CIMElement
#     """
#     The INSTANCEPATH element defines the absolute path to a CIM
#     Instance. It is comprised of a Namespace path and an Instance Name
#     (model path). 
 
#     <!ELEMENT INSTANCEPATH (NAMESPACEPATH, INSTANCENAME)>
#     """
    
        def initialize(namespacepath, instancename)
            super("INSTANCEPATH")
            self.add_element(namespacepath)
            self.add_element(instancename)
        end
    end

    class LOCALINSTANCEPATH < CIMElement
#     """
#     The LOCALINSTANCEPATH element defines the local path to a CIM
#     Instance. It is comprised of a local Namespace path and an
#     Instance Name (model path). 
 
#     <!ELEMENT LOCALINSTANCEPATH (LOCALNAMESPACEPATH,INSTANCENAME)>
#     """
    
        def initialize(localpath, instancename)
            super("LOCALINSTANCEPATH")
            self.add_element(localpath)
            self.add_element(instancename)
        end
    end

    class INSTANCENAME < CIMElement
#     """
#     The INSTANCENAME element defines the location of a CIM Instance
#     within a Namespace (it is referred to in the CIM Specification
#     as a Model Path). It is comprised of a class name and a key
#     binding information. 

#     If the Class has a single key property, then a single KEYVALUE or
#     VALUE.REFERENCE subelement may be used to describe the
#     (necessarily) unique key value without a key name. Alternatively a
#     single KEYBINDING subelement may be used instead. 

#     If the Class has more than one key property, then a KEYBINDING
#     subelement MUST appear for each key. 

#     If there are no key-bindings specified, the instance is assumed to
#     be a singleton instance of a keyless Class. 
 
#     <!ELEMENT INSTANCENAME (KEYBINDING* | KEYVALUE? | VALUE.REFERENCE?)>
#     <!ATTLIST INSTANCENAME
#         %ClassName;>
#     """
    
        def initialize(classname, data)
            super("INSTANCENAME")
            self.add_attribute("CLASSNAME", classname)
            unless data.nil?
                self.add_elements(data)
            end
        end
    end

    class OBJECTPATH < CIMElement
#     """
#     The OBJECTPATH element is used to define a full path to a single
#     CIM Object (Class or Instance). 
 
#     <!ELEMENT OBJECTPATH (INSTANCEPATH | CLASSPATH)>
#     """
    
        def initialize(data)
            super("OBJECTPATH")
            self.add_element(data)
        end
    end

    class KEYBINDING < CIMElement
#     """
#     The KEYBINDING element defines a single key property value binding.
 
#     <!ELEMENT KEYBINDING (KEYVALUE | VALUE.REFERENCE)>
#     <!ATTLIST KEYBINDING
#         %CIMName;>
#     """
    
        def initialize(name, data)
            super("KEYBINDING")
            self.setName(name)
            self.add_element(data)
        end
    end

    class KEYVALUE < CIMElement
#     """
#     The KEYVALUE element defines a single property key value when the
#     key property is a non-reference type. 
 
#     <!ELEMENT KEYVALUE (#PCDATA)>
#     <!ATTLIST KEYVALUE
#         VALUETYPE    (string|boolean|numeric)  'string'
#         %CIMType;    #IMPLIED>
#     """

        def initialize(data, value_type = nil, cim_type = nil)
            super("KEYVALUE")
            if (value_type.nil?)
                self.add_attribute("VALUETYPE", "string")        
            else
                self.add_attribute("VALUETYPE", value_type)        
            end
            self.add_optional_attribute("TYPE", cim_type)
            unless data.nil?
                self.add_text(data)        
            end
        end
    end

# Object definition elements

    class CLASS < CIMElement
#     """
#     The CLASS element defines a single CIM Class.
 
#     <!ELEMENT CLASS (QUALIFIER*,(PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE)*,
#                      METHOD*)>
#     <!ATTLIST CLASS 
#         %CIMName;
#         %SuperClass;>
#     """

        def initialize(classname, properties = [], methods = [],
                       qualifiers = [], superclass = nil)
            super("CLASS")
            self.setName(classname)
            self.add_optional_attribute("SUPERCLASS", superclass)
            self.add_elements(qualifiers)
            self.add_elements(properties)
            self.add_elements(methods)
        end
    end

    class INSTANCE < CIMElement
#     """
#     The INSTANCE element defines a single CIM Instance of a CIM Class.
 
#     <!ELEMENT INSTANCE (QUALIFIER*,(PROPERTY | PROPERTY.ARRAY |
#                                     PROPERTY.REFERENCE)*)>
#     <!ATTLIST INSTANCE
#          %ClassName;
#           xml:lang   NMTOKEN  #IMPLIED>
#     """
        def initialize(classname, properties = [], qualifiers = [],
                       xml_lang = nil)
            super("INSTANCE")
            self.add_attribute("CLASSNAME", classname)
            self.add_optional_attribute("xml:lang", xml_lang)
            self.add_elements(qualifiers)
            self.add_elements(properties)
        end
    end

    class QUALIFIER < CIMElement
#     """
#     The QUALIFIER element defines a single CIM Qualifier. If the
#     Qualifier has a non-array type, it contains a single VALUE element
#     representing the value of the Qualifier. If the Qualifier has an
#     array type, it contains a single VALUE.ARRAY element to represent
#     the value.

#     If the Qualifier has no assigned value then the VALUE element MUST
#     be absent. 
 
#     <!ELEMENT QUALIFIER ((VALUE | VALUE.ARRAY)?)>
#     <!ATTLIST QUALIFIER 
#         %CIMName;
#         %CIMType;               #REQUIRED 
#         %Propagated;
#         %QualifierFlavor;
#         xml:lang  NMTOKEN  #IMPLIED>
#     """
    
        def initialize(name, type, data, propagated = nil,
                       overridable = nil, tosubclass = nil, toinstance = nil,
                       translatable = nil, xml_lang = nil)
            super("QUALIFIER")
            self.setName(name)
            self.add_attribute("TYPE", type)
            unless propagated.nil?
                self.add_attribute("PROPAGATED", propagated.to_s.downcase)
            end
            unless overridable.nil?
                self.add_attribute("OVERRIDABLE", overridable.to_s.downcase)
            end
            unless tosubclass.nil?
                self.add_attribute("TOSUBCLASS", tosubclass.to_s.downcase)
            end
            unless toinstance.nil?
                self.add_attribute("TOINSTANCE", toinstance.to_s.downcase)
            end
            unless translatable.nil?
                self.add_attribute("TRANSLATABLE", translatable.to_s.downcase)
            end
            self.add_optional_attribute("xml:lang", xml_lang)

            self.add_element(data)

        end
    end

    class PROPERTY < CIMElement
#     """
#     The PROPERTY element defines a single (non-array) CIM Property
#     that is not a reference. It contains a single VALUE element
#     representing the value of the Property. 

#     If the Property has no assigned value then the VALUE element MUST be
#     absent.

#     CIM Reference Properties are described using the
#     PROPERTY.REFERENCE element.
 
#     <!ELEMENT PROPERTY (QUALIFIER*, VALUE?)>
#     <!ATTLIST PROPERTY 
#         %CIMName;
#         %ClassOrigin;
#         %Propagated;
#         %CIMType;           #REQUIRED 
#         xml:lang  NMTOKEN  #IMPLIED>
#     """

        def initialize(name, type, value = nil, class_origin = nil,
                       propagated = nil, qualifiers = [], xml_lang = nil)
            super("PROPERTY")
            self.setName(name)
            self.add_attribute("TYPE", type)
            self.add_optional_attribute("CLASSORIGIN", class_origin)
            unless propagated.nil?
                self.add_attribute("PROPAGATED", propagated.to_s.downcase)
            end
            self.add_optional_attribute("xml:lang", xml_lang)
            self.add_elements(qualifiers)
            self.add_optional_element(value)
        end
    end

    class PROPERTY_ARRAY < CIMElement
#     """
#     The PROPERTY.ARRAY element defines a single CIM Property with an
#     array type. It contains a single VALUE.ARRAY element  representing
#     the value of the Property. 

#     If the Property has no assigned value then the VALUE.ARRAY element
#     MUST be absent. 

#     There is no element to model a Property that contains an array of
#     references as this is not a valid Property type according to CIM. 
 
#     <!ELEMENT PROPERTY.ARRAY (QUALIFIER*,VALUE.ARRAY?)>
#     <!ATTLIST PROPERTY.ARRAY 
#        %CIMName;
#        %ArraySize;
#        %ClassOrigin;
#        %Propagated;
#         %CIMType;           #REQUIRED 
#         xml:lang  NMTOKEN  #IMPLIED>
#     """
    
        def initialize(name, type, value_array = nil, 
                       array_size = nil, class_origin = nil, 
                       propagated = nil, qualifiers = [],
                       xml_lang = nil)
            super("PROPERTY.ARRAY")
            self.setName(name)
            self.add_attribute("TYPE", type)
            self.add_optional_attribute("ARRAYSIZE", array_size)
            self.add_optional_attribute("CLASSORIGIN", class_origin)
            unless propagated.nil?
                self.add_attribute("PROPAGATED", propagated.to_s.downcase)
            end
            self.add_optional_attribute("xml:lang", xml_lang)
            self.add_elements(qualifiers)
            self.add_optional_element(value_array)
        end
    end

    class PROPERTY_REFERENCE < CIMElement
#     """
#     The PROPERTY.REFERENCE element models a single CIM Property with
#     reference semantics. In future the features of XML Linking may
#     be used to identify linking elements within the XML Document; as
#     XML Linking is currently only at Working Draft status no explicit
#     dependencies have been made at this point. 
 
#     <!ELEMENT PROPERTY.REFERENCE (QUALIFIER*, VALUE.REFERENCE?)>
#     <!ATTLIST PROPERTY.REFERENCE
#         %CIMName;
#         %ReferenceClass;
#         %ClassOrigin;
#         %Propagated;>
#     """
    
        def initialize(name, value_reference = nil, 
                       reference_class = nil, class_origin = nil, 
                       propagated = nil, qualifiers = [],
                       xml_lang = nil)
            super("PROPERTY.REFERENCE")
            self.setName(name)
            self.add_optional_attribute("REFERENCECLASS", reference_class)
            self.add_optional_attribute("CLASSORIGIN", class_origin)
            unless propagated.nil?
                self.add_attribute("PROPAGATED", propagated.to_s.downcase)
            end
            self.add_optional_attribute("xml:lang", xml_lang)
            self.add_elements(qualifiers)
            self.add_optional_element(value_reference)
        end
    end

    class METHOD < CIMElement
#     """
#     The METHOD element defines a single CIM Method. It may have
#     Qualifiers, and zero or more parameters. 

#     The order of the PARAMETER, PARAMETER.REFERENCE, PARAMETER.ARRAY
#     and PARAMETER.REFARRAY subelements is not significant. 
 
#     <!ELEMENT METHOD (QUALIFIER*, (PARAMETER | PARAMETER.REFERENCE|
#                                    PARAMETER.ARRAY | PARAMETER.REFARRAY)*)>
#     <!ATTLIST METHOD 
#         %CIMName;
#         %CIMType;          #IMPLIED 
#         %ClassOrigin;
#         %Propagated;>
#     """
    
        def initialize(name, parameters = [],
                       return_type = nil, class_origin = nil, propagated = nil, qualifiers = [])
            super("METHOD")
            self.setName(name)
            self.add_optional_attribute("TYPE", return_type)
            self.add_optional_attribute("CLASSORIGIN", class_origin)
            unless propagated.nil?
                self.add_attribute("PROPAGATED", propagated.to_s.downcase)
            end
            self.add_elements(qualifiers)
            self.add_elements(parameters)
        end
    end

    class PARAMETER < CIMElement
#     """
#     The PARAMETER element defines a single (non-array, non-reference)
#     Parameter to a CIM Method. The parameter MAY have zero or more
#     Qualifiers. 
 
#     <!ELEMENT PARAMETER (QUALIFIER*)>
#     <!ATTLIST PARAMETER 
#         %CIMName;
#         %CIMType;      #REQUIRED>
#     """
    
        def initialize(name, type, qualifiers = [])
            super("PARAMETER")
            self.setName(name)
            self.add_attribute("TYPE", type)
            self.add_elements(qualifiers)
        end
    end
    
    class PARAMETER_REFERENCE < CIMElement
#     """
#     The PARAMETER.REFERENCE element defines a single reference
#     Parameter to a CIM Method. The parameter MAY have zero or more
#     Qualifiers.
 
#     <!ELEMENT PARAMETER.REFERENCE (QUALIFIER*)>
#     <!ATTLIST PARAMETER.REFERENCE
#         %CIMName;
#         %ReferenceClass;>
#     """
    
        def initialize(name, reference_class = nil, qualifiers = [])
            super("PARAMETER.REFERENCE")
            self.setName(name)
            self.add_optional_attribute("REFERENCECLASS", reference_class)
            self.add_elements(qualifiers)
        end
    end

    class PARAMETER_ARRAY < CIMElement
#     """
#     The PARAMETER.ARRAY element defines a single Parameter to a CIM
#     Method that has an array type. The parameter MAY have zero or more
#     Qualifiers.
 
#     <!ELEMENT PARAMETER.ARRAY (QUALIFIER*)>
#     <!ATTLIST PARAMETER.ARRAY
#         %CIMName;
#         %CIMType;           #REQUIRED
#         %ArraySize;>
#     """
    
        def initialize(name, type, array_size = nil, qualifiers = [])
            super("PARAMETER.ARRAY")
            self.setName(name)
            self.add_attribute("TYPE", type)
            self.add_optional_attribute("ARRAYSIZE", array_size)
            self.add_elements(qualifiers)
        end
    end

    class PARAMETER_REFARRAY < CIMElement
#     """
#     The PARAMETER.REFARRAY element defines a single Parameter to a CIM
#     Method that has an array of references type. The parameter MAY
#     have zero or more Qualifiers. 
 
#     <!ELEMENT PARAMETER.REFARRAY (QUALIFIER*)>
#     <!ATTLIST PARAMETER.REFARRAY
#         %CIMName;
#         %ReferenceClass;
#         %ArraySize;>
#     """
    
        def initialize(name, reference_class = nil, array_size = nil,
                       qualifiers = [])
            super("PARAMETER.REFARRAY")
            self.setName(name)
            self.add_optional_attribute("REFERENCECLASS", reference_class)
            self.add_optional_attribute("ARRAYSIZE", array_size)
            self.add_elements(qualifiers)
        end
    end
            

    class TABLECELL_DECLARATION < CIMElement
#    """
#    The TABLECELL.DECLARATION element describes a TABLECELL that is
#    not a reference or an array of references.

    
#     <!ELEMENT TABLECELL.DECLARATION EMPTY>
#     <!ATTLIST TABLECELL.DECLARATION
#         %CIMName;
#         %CIMType;                    #REQUIRED
#         ISARRAY         (true|false) "false"
#         %ARRAYSIZE;
#         CELLPOS          CDATA       #REQUIRED
#         SORTPOS          CDATA       #IMPLIED
#         SORTDIR        (ASC|DESC)    #IMPLIED>
#     """
    end

    class TABLECELL_REFERENCE < CIMElement
#     """

#     The TABLECELL.REFERENCE element defines a TABLECELL that contains
#     reference or reference array values.

#     <!ELEMENT TABLECELL.REFERENCE EMPTY>
#     <!ATTLIST TABLECELL.REFERENCE
#         %CIMName;
#         %ReferenceClass;             #REQUIRED
#         ISARRAY        (true|false)  "false"
#         %ARRAYSIZE;
#         CELLPOS         CDATA        #REQUIRED
#         SORTPOS          CDATA       #IMPLIED
#         SORTDIR         (ASC|DESC)   #IMPLIED>
#      """
    end

    class TABLEROW_DECLARATION <CIMElement
#     """

#     The TABLEROW.DECLARATION element contains a definition for each
#     TABLECELL in the TABLEROW.

#     <!ELEMENT TABLEROW.DECLARATION (TABLECELL.DECLARATION
#                                     | TABLECELL.REFERENCE)*>
#     """
    end

    class TABLE < CIMElement
#     """
#     The TABLE element defines the result of a CIM Query.  A TABLE
#     element consists of a TABLEROW.DECLARATION followed by 0 or more
#     rows.

#     <!ELEMENT TABLE(TABLEROW.DECLARATION,(TABLEROW)*)>
#     """
    end

    class TABLEROW < CIMElement
#    """
#
#    The TABLEROW element defines the values for a single row of a
#    table.  A value for each cell of the row MUST be specified.  If a
#    value has no assigned value, the VALUE.NULL element MUST be used.
#
#    <!ELEMENT TABLEROW (VALUE | VALUE.ARRAY | VALUE.REFERENCE |
#                        VALUE.REFARRAY | VALUE.NULL)*>
#    """
    end

# Message elements

    class MESSAGE < CIMElement
#     """
#     The MESSAGE element models a single CIM message.  This element is
#     used as the basis for CIM Operation Messages and CIM Export
#     Messages.

#     <!ELEMENT MESSAGE (SIMPLEREQ | MULTIREQ | SIMPLERSP | MULTIRSP) |
#                       MULTIEXPRSP)>
#     <!ATTLIST MESSAGE
# 	ID CDATA #REQUIRED
# 	PROTOCOLVERSION CDATA #REQUIRED>
#     """
    
        def initialize(data, message_id, protocol_version)
            super("MESSAGE")
            self.add_attribute("ID", message_id)
            self.add_attribute("PROTOCOLVERSION", protocol_version)
            self.add_element(data)
        end
    end

    class MULTIREQ < CIMElement
#     """
#     The MULTIREQ element defines a Multiple CIM Operation request.  It
#     contains two or more subelements defining the SIMPLEREQ elements
#     that make up this multiple request.

#     <!ELEMENT MULTIREQ (SIMPLEREQ, SIMPLEREQ+)>
#     """
    
        def initialize(data)
            super("MULTIREQ")
            self.add_elements(data)
        end
    end
    
    class MULTIEXPREQ < CIMElement
#     """
#     The MULTIEXPREQ element defines a Multiple CIM Export request.  It
#     contains two or more subelements defining the SIMPLEEXPREQ
#     elements that make up this multiple request. 
    
#     <!ELEMENT MULTIEXPREQ (SIMPLEEXPREQ, SIMPLEEXPREQ+)>
#     """
    
        def initialize(data)
            super("MULTIEXPREQ")
            self.add_elements(data)
        end
    end

    class SIMPLEREQ < CIMElement
#     """
#     The SIMPLEREQ element defines a Simple CIM Operation request.  It
#     contains either a METHODCALL (extrinsic method) element or an
#     IMETHODCALL (intrinsic method) element. 
 
#     <!ELEMENT SIMPLEREQ (IMETHODCALL | METHODCALL)>
#     """
    
        def initialize(data)
            super("SIMPLEREQ")
            self.add_element(data)
        end
    end

    class SIMPLEEXPREQ < CIMElement
#     """
#     The SIMPLEEXPREQ element defines a Simple CIM Export request.  It
#     contains an EXPMETHODCALL (export method). 
    
#     <!ELEMENT SIMPLEEXPREQ (EXPMETHODCALL)>
#     """
    
        def initialize(data)
            super("SIMPLEEXPREQ")
            self.add_element(data)
        end
    end

    class IMETHODCALL < CIMElement
#     """
#     The IMETHODCALL element defines a single intrinsic method
#     invocation.  It specifies the target local namespace, followed by
#     zero or more IPARAMVALUE subelements as the parameter values to be
#     passed to the method. If the RESPONSEDESTINATION element is
#     specified, the intrinsic method call MUST be interpreted as an
#     asynchronous method call. 
    
#     <!ELEMENT IMETHODCALL (LOCALNAMESPACEPATH, IPARAMVALUE*),
#                           RESPONSEDESTINATION?)>
#     <!ATTLIST IMETHODCALL
# 	%CIMName;>
#     """
    
        def initialize(name, localnamespacepath, iparamvalues = [],
                       responsedestination = nil)
            super("IMETHODCALL")
            self.setName(name)
            self.add_element(localnamespacepath)        
            self.add_elements(iparamvalues)
            self.add_optional_element(responsedestination)        
        end
    end

    class METHODCALL < CIMElement
#     """
#     The METHODCALL element defines a single method invocation on a
#     Class or Instance.  It specifies the local path of the target
#     Class or Instance, followed by zero or more PARAMVALUE subelements
#     as the parameter values to be passed to the method. If the
#     RESPONSEDESTINATION element is specified, the method call MUST be
#     interpreted as an asynchronous method call. 

#     <!ELEMENT METHODCALL ((LOCALINSTANCEPATH | LOCALCLASSPATH), PARAMVALUE*)>
#     <!ATTLIST METHODCALL
# 	%CIMName;>
#     """
    
        def initialize(name, localpath, paramvalues = [],
                       responsedestination = nil)
            super("METHODCALL")
            self.setName(name)
            self.add_element(localpath)
            self.add_elements(paramvalues)
            self.add_optional_element(responsedestination)        
        end
    end

    class EXPMETHODCALL < CIMElement
#     """
#     The EXPMETHODCALL element defines a single export method
#     invocation.  It specifies zero or more  <EXPPARAMVALUE>
#     subelements as the parameter values to be passed to the method. 
    
#     <!ELEMENT EXPMETHODCALL (EXPPARAMVALUE*)>
#     <!ATTLIST EXPMETHODCALL
# 	%CIMName;>
#     """
    
        def initialize(name, params = [])
            super("EXPMETHODCALL")
            self.setName(name)
            self.add_elements(params)
        end
    end

    class PARAMVALUE < CIMElement
#     """
#     The PARAMVALUE element defines a single extrinsic method named
#     parameter value. If no subelement is present this indicates that
#     no value has been supplied for this parameter.
    
#     <!ELEMENT PARAMVALUE (VALUE | VALUE.REFERENCE | VALUE.ARRAY |
#                           VALUE.REFARRAY)?>
#     <!ATTLIST PARAMVALUE
# 	%CIMName;
#       %ParamType;    #IMPLIED>
#     """
    
        def initialize(name, data = nil, param_type = nil)
            super("PARAMVALUE")
            self.setName(name)
            self.add_optional_attribute("PARAMTYPE", param_type)
            self.add_optional_element(data)
        end
    end

    class IPARAMVALUE < CIMElement
#     """
#     The IPARAMVALUE element defines a single intrinsic method named
#     parameter value. If no subelement is present this indicates that
#     no value has been supplied for this parameter. 

#     <!ELEMENT IPARAMVALUE (VALUE | VALUE.ARRAY | VALUE.REFERENCE |
#                            INSTANCENAME | CLASSNAME | QUALIFIER.DECLARATION |
#                            CLASS | INSTANCE | VALUE.NAMEDINSTANCE)?>
#     <!ATTLIST IPARAMVALUE
# 	%CIMName;
#       %ParamType;    #IMPLIED>
#     """
    
        def initialize(name, data = nil, param_type = nil)
            super("IPARAMVALUE")
            self.setName(name)
            self.add_optional_attribute("PARAMTYPE", param_type)
            self.add_optional_element(data)
        end
    end

    class EXPPARAMVALUE < CIMElement
#     """
#     The EXPPARAMVALUE element defines a single export method named
#     parameter value.  If no subelement is present this indicates that
#     no value has been supplied for this parameter. 
    
#     <!ELEMENT EXPPARAMVALUE (INSTANCE)?>
#     <!ATTLIST EXPPARAMVALUE
# 	%CIMName;>
#     """
    
        def initialize(name, data = nil)
            super("EXPPARAMVALUE")
            self.setName(name)
            self.add_optional_element(data)
        end
    end

    class MULTIRSP < CIMElement
#     """
#     The MULTIRSP element defines a Multiple CIM Operation response.
#     It contains two or more subelements defining the SIMPLERSP
#     elements that make up this multiple response. 
    
#     <!ELEMENT MULTIRSP (SIMPLERSP, SIMPLERSP+)>
#     """
    
        def initialize(data)
            super("MULTIRSP")
            self.add_elements(data)
        end
    end

    class MULTIEXPRSP < CIMElement
#     """
#     The MULTIEXPRSP element defines a Multiple CIM Export response.
#     It contains two or more subelements defining the SIMPLEEXPRSP
#     elements that make up this multiple response.
    
#     <!ELEMENT MULTIEXPRSP (SIMPLEEXPRSP, SIMPLEEXPRSP+)>
#     """

        def initialize(data)
            super("MULTIEXPRSP")
            self.add_elements(data)
        end
    end

    class SIMPLERSP < CIMElement
#     """
#     The SIMPLERSP element defines a Simple CIM Operation response.  It
#     contains either a METHODRESPONSE (for extrinsic methods),
#     IMETHODRESPONSE (for intrinsic methods) or a SIMPLEREQACK
#     subelement.  
    
#     <!ELEMENT SIMPLERSP (METHODRESPONSE | IMETHODRESPONSE | SIMPLEREQACK)>
#     """
    
        def initialize(data)
            super("SIMPLERSP")
            self.add_element(data)
        end
    end

    class SIMPLEEXPRSP < CIMElement
#     """
#     The SIMPLEEXPRSP element defines a Simple CIM Export response.  It
#     contains either a EXPMETHODRESPONSE (for export methods)
#     subelement. 
    
#     <!ELEMENT SIMPLEEXPRSP (EXPMETHODRESPONSE)>
#     """
    
        def initialize(data)
            super("SIMPLEEXPRSP")
            self.add_element(data)
        end
    end

    class METHODRESPONSE < CIMElement
#     """
#     The METHODRESPONSE defines the response to a single CIM extrinsic
#     method invocation.  It contains either an ERROR subelement (to
#     report a fundamental error which prevented the method from
#     executing), or a combination of an optional return value and zero
#     or more out parameter values.  
    
#     <!ELEMENT METHODRESPONSE (ERROR | (RETURNVALUE?, PARAMVALUE*))>
#     <!ATTLIST METHODRESPONSE
# 	%CIMName;>
#     """
    
        def initialize(name, data = nil)
            super("METHODRESPONSE")
            self.setName(name)
            unless data.nil?
                self.add_elements(data)
            end
        end
    end

    class EXPMETHODRESPONSE < CIMElement
#     """
#     The EXPMETHODRESPONSE defines the response to a single export
#     method invocation.  It contains either an ERROR subelement (to
#     report a fundamental error which prevented the method from
#     executing), or an optional return value. 
    
#     <!ELEMENT EXPMETHODRESPONSE (ERROR | IRETURNVALUE?)>
#     <!ATTLIST EXPMETHODRESPONSE
# 	%CIMName;>
#     """
    
        def initialize(name, data = nil)
            super("EXPMETHODRESPONSE")
            self.setName(name)
            self.add_optional_element(data)
        end
    end

    class IMETHODRESPONSE < CIMElement
#     """
#     The IMETHODRESPONSE defines the response to a single intrinsic CIM
#     method invocation.  It contains either an ERROR subelement (to
#     report a fundamental error which prevented the method from
#     executing), or an optional return value.  
    
#     <!ELEMENT IMETHODRESPONSE (ERROR | IRETURNVALUE?)>
#     <!ATTLIST IMETHODRESPONSE
# 	%CIMName;>
#     """
    
        def initialize(name, data = nil)
            super("IMETHODRESPONSE")
            self.setName(name)
            self.add_optional_element(data)
        end
    end

    class ERROR < CIMElement
#     """
#     The ERROR element is used to define a fundamental error which
#     prevented a method from executing normally. It consists of a
#     status code, an optional description and zero or more instances
#     containing detailed information about the error. 
    
#     <!ELEMENT ERROR (INSTANCE*)>
#     <!ATTLIST ERROR
# 	CODE CDATA #REQUIRED
# 	DESCRIPTION CDATA #IMPLIED>
#     """
    
        def initialize(code, description = nil, instances = [])
            super("ERROR")
            self.add_attribute("CODE", code)
            self.add_optional_attribute("DESCRIPTION", description)
            self.add_elements(instances)
        end
    end

    class RETURNVALUE < CIMElement
#     """
#     The RETURNVALUE element specifies the value returned from an
#     extrinsic method call. 
    
#    <!ELEMENT RETURNVALUE (VALUE | VALUE.REFERENCE)>
#    <!ATTLIST RETURNVALUE
#        %ParamType;     #IMPLIED>                           
#     """
    
        def initialize(data, param_type = nil)
            super("RETURNVALUE")
            self.add_optional_attribute("PARAMTYPE", param_type)
            self.add_element(data)
        end
    end

    class IRETURNVALUE < CIMElement
#     """
#     The IRETURNVALUE element specifies the value returned from an
#     intrinsic method call. 
    
#     <!ELEMENT IRETURNVALUE (CLASSNAME* | INSTANCENAME* | VALUE* |
#                             VALUE.OBJECTWITHPATH* |
#                             VALUE.OBJECTWITHLOCALPATH* | VALUE.OBJECT* |
#                             OBJECTPATH* | QUALIFIER.DECLARATION* |
#                             VALUE.ARRAY? | VALUE.REFERENCE? | CLASS* |
#                             INSTANCE* | VALUE.NAMEDINSTANCE*)>
#     """
    
        def initialize(data)
            super("IRETURNVALUE")
            self.add_optional_element(data)
        end
    end

    class RESPONSEDESTINATION < CIMElement
#     """
#     The RESPONSEDESTINATION element contains an instance that
#     describes the desired destination for the response.

#     <!ELEMENT RESPONSEDESTINATON (INSTANCE)>
#     """

        def initialize(data)
            super("RESPONSEDESTINATON")
            self.add_element(data);
        end
    end

    class SIMPLEREQACK < CIMElement
#     """
#     The SIMPLEREQACK defines the acknowledgement response to a Simple
#     CIM Operation asynchronous request. The ERROR subelement is used
#     to report a fundamental error which prevented the asynchronous
#     request from being initiated.

#     <!ELEMENT SIMPLEREQACK (ERROR?)>
#     <!ATTLIST SIMPLEREQACK 
#         INSTANCEID CDATA     #REQUIRED>
#     """

        def initialize(instanceid, data)
            super("SIMPLEREQACK")
            self.add_optional_attribute("INSTANCEID", instanceid)
            self.add_optional_element(data)
        end
    end
end
